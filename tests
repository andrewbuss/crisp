; These are the docs and also the test cases. Each logical line
; in this script should evaluate to pass

; Comments are prefixed by ; and continue to the end of the line
; Whitespace and newlines are ignored
; Undefined symbols evaluate to themselves

pass

; () is nil - the only false-y cell;
; everything else is considered true

; if evaluates and returns its second arg if the first is true
; otherwise it evaluates and returns the third arg
if 1 pass fail
if () fail pass

; Return pass if actual == expected, else fail
def test lambda (actual expected) if (equal actual expected) pass fail

; The built-in equal function returns nil if its arguments are nil
; In a few lines we'll rewrite the test function to take this into account

test 1 1

; The quote function returns its arguments (a list) unevaluated
; 'cdr is syntactic sugar for (quote . cdr)

test (car (quote cdr)) 'cdr

; The eval function evaluates its argument
test (eval sum 1 2) 3
test (eval '(car (cons a b))) a

; test that the test fails correctly!
test (test 1 2) fail

; the opposite of nil is true
def not lambda a if a () true

test (not ()) true
test (not (not true)) true

; if a and b are non-nil, return b
def and lambda (a b) if a b ()
test (and foo bar) bar
test (not (and foo ())) true
test (not (and () foo)) true
test (not (and () ())) true

; return a if either a or b are non-nil
def or lambda (a b) if a a b
def nor lambda (a b) not (or a b)

; ispair returns its single argument if it is a pair; otherwise nil
test (not (ispair a)) true
test (car (ispair (a b))) a

; if more than three arguments are passed to the if function,
; everything past the second is treated as the "else"
; .. including another if!
def list-equal lambda (a b) (
    if (nor a b)
        true
    if (not (and (ispair a) (ispair b)))
        (equal a b)
    if (or  (equal (car a) (car b))
            (nor (car a) (car b)))
        (list-equal (cdr a) (cdr b))
    ()
)

test (list-equal () ()) true
test (list-equal (a b) (a b)) true
test (list-equal (() b) (() b)) true
test (not (list-equal (a ()) (a b))) true
test (not (list-equal (a d f) (a f d))) true

def loose-equal lambda (a b) (
    if (and (ispair a) (ispair b))
        (if (list-equal a b) a)
    if (equal a b) a ; are the results non-nil and equal?
    nor a b
)

; we've tested quote and eval, and implemented nor
; redefine our test to pass if actual == expected == nil
; and tell us the details of the test which failed
def test lambda (actual expected) (
    if (loose-equal (eval actual) expected)
        (pass: actual == expected)
        (fail: actual != expected)
)

test '(or foo ()) foo
test '(or () foo) foo
test '(or foo foo) foo
test '(nor () ()) true

; The outer parentheses are used here to include
; the entire definition in the same logical line

; Since the if statement comprises the entire lambda body,
; the parentheses would not be necessary if we put the
; definition all on one input line

; (reduce f (1 2 3) init) is equivalent to (f 1 (f 2 (f 3 init)))
def reduce lambda (fn list init) (
    if (not list)
        init
        fn (car list) (reduce fn (cdr list) init))

; f is not defined here so it is left unevaluated.
;test '(reduce f (1 2 3) 0) (f 1 (f 2 (f 3 0)))
; waiting to test this until we have a function for recursively comparing complex lists

test '(reduce sum (1 2 3) 0) 6

; (map f (1 2 3)) is equivalent to (f 1) (f 2) (f 3)
def map lambda (fn list) (
    if (not list)
        ()
        cons (fn (car list)) (map fn (cdr list)))

; sum returns the sum of its arguments; it does not sum lists
test '(sum 1 2 3 4) 10

; but if we apply sum to a list, we achieve the equivalent result
def sumlist lambda l apply sum l
test '(sumlist (1 2 3 4)) 10

; now we can test map

test '(map sumlist ((2 4 6) (1 3 5 7) (2 3))) (12 16 5)

; is the entire list non-nil?
def all lambda list reduce and list true

test '(all (1 2 foo bar)) true
test '(all (1 2 () bar)) ()
test '(all ()) true

; is at least one element non-nil?
def any lambda list reduce or list ()

test '(any (1 2 foo bar)) 1
test '(any (1 2 () bar)) 1
test '(any (() () ())) ()
test '(any ()) ()

; are all elements nil?
def none lambda list (
    if (not list)
        true ; all elements of an empty list are nil
        reduce nor list ())

test '(none (1 2 foo bar)) ()
test '(none (1 2 () bar)) ()
test '(none (() () ())) true
test '(none (())) true
test '(none ()) true

; asc: return the minimum arg if args are in strictly ascending order
;      otherwise nil
test '(asc 1 2 3) 1
test '(asc 3 2 1) ()

; sum: return the sum of its arguments
test '(sum 1 2 3 4) 10

; product: return the product of its arguments
test '(product 1 2 3 4) 24

; (apply f '(a b c)) is equivalent to (f a b c)
test '(apply sum '(1 2 3 4)) 10

; boring recursive example
def factorial lambda x (
    if (asc x 1)
        1
        (product x (factorial (sum x -1))))

test '(factorial 19) 121645100408832000

; *exciting* and slow recursive example
def fib lambda x (
    if (asc x 2)
        x
        (sum (fib (sum x -1)) (fib (sum x -2))))

test '(fib 10) 55

; faster recursive example
def fibpair lambda x (
    if (asc x 2)
        (1 1)
        (apply  (lambda (a b) b (sum a b))
                (fibpair (sum x -1))))


def fib lambda x (car (fibpair x))

test '(fibpair 10) (55 89)
test '(fib 92) 7540113804746346429

; some lambda regression tests

test '((lambda x x) 1) 1
test '((lambda (x) x) 1) 1
test '((lambda (x) (x)) 1) 1
test '((lambda x (x)) 1) 1

test '((lambda (x y) x) 1 2) 1
test '((lambda (x y) y) 1 2) 2

test '((lambda (a b) (a b)) 1 2) (quote 1 2)
test '(car (cdr ((lambda (a b) a b) 1 2))) 2
test '(car (cdr ((lambda (a b) (a b)) 1 2))) 2
test '(car (cdr ((lambda (a b) list a b) 1 2))) 2

