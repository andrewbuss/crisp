; the opposite of nil is true
def not lambda a if a () true

; if a and b are non-nil, return b
def and lambda (a b) if a b ()

; return a if either a or b are non-nil
def or lambda (a b) if a a b

def nor lambda (a b) not (or a b)

; if more than three arguments are passed to the if function,
; everything past the second is treated as the "else"
; .. including another if!
def list-equal lambda (a b) (
    if (nor a b)
        true
    if (not (and (ispair a) (ispair b)))
        (equal a b)
    if (or  (equal (car a) (car b))
            (nor (car a) (car b)))
        (list-equal (cdr a) (cdr b))
    ()
)

def loose-equal lambda (a b) (
    if (and (ispair a) (ispair b))
        (if (list-equal a b) a)
    if (equal a b) a ; are the results non-nil and equal?
    nor a b
)

def test lambda (actual expected) (
    if (loose-equal (eval actual) expected)
        (pass: actual == expected)
        (fail: actual != expected)
)

; The outer parentheses are used here to include
; the entire definition in the same logical line

; Since the if statement comprises the entire lambda body,
; the parentheses would not be necessary if we put the
; definition all on one input line

; (reduce f (1 2 3) init) is equivalent to (f 1 (f 2 (f 3 init)))
def reduce lambda (fn list init) (
    if (not list)
        init
        fn (car list) (reduce fn (cdr list) init))

; (map f (1 2 3)) is equivalent to (f 1) (f 2) (f 3)
def map lambda (fn list) (
    if (not list)
        ()
        cons (fn (car list)) (map fn (cdr list)))

; is the entire list non-nil?
def all lambda list reduce and list true

; is at least one element non-nil?
def any lambda list reduce or list ()

; are all elements nil?
def none lambda list (
    if (not list)
        true ; all elements of an empty list are nil
        reduce nor list ())


; yield a list containing each element i of l
; such that (f i) is non-nil
def filter lambda (f l) (
    if (not l)
        ()
    if (f (car l))
        (cons (car l) (filter f (cdr l)))
        (filter f (cdr l))
)

; build r backward as we recurse forwards through l
def reverse-copy lambda (l r)(
    if l
        (reverse-copy (cdr l) (cons (car l) r))
        r
)

; return l in reverse order
def reverse lambda l reverse-copy l () ; wrapper

def >= lambda (a b) or (equal a b) (asc b a)
def reversed-range lambda end (
    if (>= end 0)
        (cons end (reversed-range (sum end -1)))
        ())

; return 0 to end, right-exclusive
def range lambda end reverse (reversed-range (sum end -1))

; evaluate arguments and return NIL
; useful for functions with side-effects
def void lambda _

def glib dlopen libglib-2.0.so
def libc dlopen libc.so.6

; Symbols of the form <libpath>.<fnname> are resolved to library functions if possible
def puts lambda l void ((map libc.putchar l) (libc.putchar 0xa))

